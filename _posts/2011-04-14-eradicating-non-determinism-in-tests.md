---
title: テストにおける非決定性の排除
tags: [continuous integration, delivery, testing]
---

[Eradicating Non-Determinism in Tests](https://martinfowler.com/articles/nonDeterminism.html)

自動化されたリグレッションスイートは、ソフトウェアプロジェクトにおいて本番環境の欠陥を減らし、進化的設計を実現するうえで重要な役割を果たします。開発チームと話をする中で、私は非決定的なテストの問題についてよく耳にします。非決定的なテストとは成功したり失敗したりするようなテストのことです。制御されていないまま放置された非決定的テストは、自動化されたリグレッションスイートの価値を完全に破壊してしまう可能性があります。この記事では、非決定的テストに対処する方法の概要を説明します。手始めにはそういったテストを隔離することで他のテストへのダメージを減らすことができますが、それでもすぐに修正しなければなりません。そのため、非決定的テストのよくある原因である、分離の欠如、非同期的な挙動、リモートサービス、時間、リソースリークなどへの対処法について説明します。

<!-- TOC -->
- [なぜ非決定的なテストは問題なのか](#なぜ非決定的なテストは問題なのか)
- [隔離](#隔離)
- [分離の欠如](#分離の欠如)
- [非同期的な挙動](#非同期的な挙動)
- [リモートサービス](#リモートサービス)
- [時間](#時間)
- [リソースリーク](#リソースリーク)

<!-- /TOC -->

私は、ThoughtWorksが多くの困難なエンタープライズアプリケーションに取り組み、これまでほとんど成功したことのない多くのクライアントに成功をもたらしているのを見て楽しんでいました。私たちの経験によって、10年前にマニフェストを書いたときには物議をかもしていたアジャイル手法がソフトウェア開発を成功に導くことを実証してきました。

アジャイル開発には様々な種類がありますが、私たちが行っていることの中では自動テストが中心的な役割を果たしています。自動テストは、エクストリームプログラミングの最初からの中核的なアプローチであり、その哲学が私たちのアジャイル開発の最大のインスピレーションとなっています。そのため、私たちはソフトウェア開発の中核となる部分として自動テストを使用する多くの経験を積んできました。

自動テストは、書籍の中で読む限りは簡単に見えるかもしれません。実際、基本的な考え方は非常にシンプルです。しかし、納品プロジェクトのプレッシャーの中では、書籍ではあまり注目されていないような試練が降りかかります。私もよく知っていますが、書籍の著者は核心を突くために多くの詳細を省く傾向があります。私たちのデリバリチームとの会話の中で、私たちが繰り返し遭遇する問題の1つは、テストが信頼性を欠くようになり、信頼性が低すぎて人々がテストが成功するか失敗するかに注意を払わなくなるというものです。この信頼性の低さの主な原因は、いくつかのテストが非決定的になっていることです。

テストが非決定的であるというのは、コードやテスト、環境に変更がなくても、成功したり失敗したりする場合です。そのようなテストは、失敗した後再実行すると合格します。このようなテストの失敗は、一見ランダムに見えます。

非決定性はあらゆる種類のテストに害をもたらしますが、特に受け入れテストや機能テストのような広い範囲のテストに影響を与えやすいです。

## なぜ非決定的なテストは問題なのか

非決定的なテストは2つの問題を抱えています。1つ目は役に立たないこと、2つ目はテストスイート全体を完全に台無しにしかねない悪質な感染症であることです。結果として、デプロイメントパイプライン全体が危険にさらされる前に、できるだけ早く対処する必要があります。

まず非決定的なテストが役に立たない点について説明します。自動テストを持つことの主な利点は、リグレッションテストとして動作することでバグを検出するメカニズムを提供することです[^1]。リグレッションテストが赤になると、すぐに問題が発生していることを知ることができます。多くの場合、これは気づかないうちにバグがシステムに忍び込んでいることを示しています。

このようなバグ検出器を持つことには大きなメリットがあります。最も明らかなことは、バグが発生した直後にバグを発見し、修正することができるということです。バグをすぐにつぶすことができるので開発が快適になるだけでなく、あなたの頭の中にフレッシュな状態で残っている最後の変更によって引き起こされたバグであるということが明確なのでそのバグを取り除くのがより簡単になります。その結果、どこでバグを探せばいいのかがわかるようになります。これにより、バグとの闘いの半分以上は完了したといってもよいでしょう。

第2の利点は、バグ検出器に自信を持てるようになると、へまをしたときにバグ検出器によってすぐにバグに気づくことができ、間違いをすぐに修正できることを知っているので、大きな変更を行う勇気が出てくるということです。[^2] これがなければ、チームはコードをきれいに保つために必要な変更を行うことに怯えてしまい、コードベースが腐り、開発スピードが急落してしまいます。

非決定的テストの問題は、それらが赤になったとき、それがバグによるものなのか、単に非決定的な動作の一部なのか、見当がつかないことです。こういったテストでは、非決定的な失敗は比較的よくあることになってしまいテストが赤になっても肩をすくめるだけで済ませてしまうようになります。一度リグレッションテストの失敗を無視し始めると、そのテストは役に立たないので、捨てたほうがいいかもしれません[^3]。

実際、非決定的なテストは本当に捨てるべきなのです。そうしないと、それは他のテストに伝染するからです。もしあなたが100のテストスイートを持っていて、そのうちの10個が非決定的なテストだったとすると、そのテストスイートは頻繁に失敗します。最初は、人々は失敗レポートを見て、失敗が非決定的テストにあることに気づくでしょうが、すぐにそれも確認しなくなるでしょう。いったんその規律が失われると、健全な決定的テストでの失敗も無視されるようになります。その時点で、あなたはすでにゲームに敗北しているので、すべてのテストを取り除いたほうがいいかもしれません。

## 隔離

この記事での私の主な目的は、非決定的テストの一般的なケースと、非決定性を排除する方法を概説することです。しかしその前に、私は本質的なアドバイスを一つ提供します：非決定的テストを隔離しましょう。非決定的なテストがある場合は、健全なテストとは別のテストスイートに保管してください。そうすれば、健康的なテストの結果に注意を払い続け、そこから良いフィードバックを得ることができます。

そして、問題は隔離されたテストスイートをどうするかということです。それらはリグレッションテストとしては役に立ちませんが、きれいにする必要がある作業一覧として利用することができます。隔離されたテストがリグレッションテストの役に立たないからと言って、こういったテストを廃棄するべきではありません。

ここでの危険な点は、テストが隔離されたまま忘れ去られてしまうことです。これではバグ検出システムが徐々に壊れていってしまいます。そのため、テストがあまりにも長く隔離されたままにならないようにする仕組みを持つことには価値があります。私はこれを行うためのさまざまな方法を見てきました。1つは単純に隔離するテスト数に上限を設けるやり方です。例えば、隔離できるのは8つのテストまでとする、などです。一度上限に達したら、すべてのテストをクリアするために時間を費やすのです。これは、テストを修正する作業をまとめて行うというやり方で、もしこの進め方があなたの好みに合っていれば優れたやり方でしょう。もう一つの方法は、例えば1週間以上は隔離しないというように、テストが隔離される期間に時間制限を設けることです。

隔離の一般的なアプローチはメインのデプロイメントパイプラインから隔離されたテストを取り除くやり方で、そうすることで通常のビルドプロセスを継続することができます。しかし、優れたチームはより積極的に取り組みます。私たちのMingle(訳注: ThoughtWorks社がかつて開発・運営していたプロジェクトマネジメントツール)チームは、デプロイメントパイプラインの中の健全なテストの一つ後の段階に隔離テストを配置しています。そうすることで、健全なテストからフィードバックを得ることができますが、また同時に隔離されたテストを迅速に選び出すことを強制するのです。[4]

## 分離の欠如

テストを信頼性高く実行するためには、テストが実行される環境を明確に制御しなければなりません。そしてテストの開始時点での状態を把握できるようにするのです。あるテストがデータベースにデータを作成して、それをそのままにしておくと、異なるデータベースの状態に依存している可能性のある別のテストの実行を破損させてしまいます。

そのため、私はテストを分離しておくことが本当に重要だと考えています。適切に分離されたテストは、どのような順序でも実行できます。機能テストの運用範囲が大きくなればなるほど、テストを分離しておくことはますます難しくなります。非決定性の調査をしているとき、分離の欠如はよくある原因でイライラさせされます。

分離するためにはいくつかの方法があります - 開始状態を常にゼロから再構築するか、各テストでクリーンアップを適切に行うかです。一般的には前者の方が個のみですしより簡単です。特に問題の原因を見つけるのが簡単なことが多いです。初期状態を適切に構築しなかったためにテストが失敗した場合、どのテストにバグが含まれているかを確認するのは簡単です。しかし、クリーンアップをする方法では、1つのテストにはバグが含まれていても、別のテストが失敗してしまいます。そのため、本当の問題を見つけ出すのが難しいです。

空白の状態から始めることはユニットテストでは通常簡単ですが、機能テストではかなり難しくなります[^5] - 特に、そこに存在する必要があるデータベースに多くのデータがある場合です。毎回データベースを再構築することは、テスト実行に多くの時間を追加することになります。これによりクリーンアップ戦略に切り替える議論が発生します[^6]。

データベースを使用しているときに便利なトリックの1つは、トランザクションの中でテストを行い、テストの最後にトランザクションをロールバックすることです。そうすれば、トランザクションマネージャがあなたの代わりにクリーンアップしてくれるので、エラーの可能性を減らすことができます[^7]。

もう一つのアプローチは、テストのグループを実行する前に、ほぼimmutableなフィクスチャを使ってビルドを行うことです。そして、テストがその初期状態を変更しないようにします(変更する場合は、ティアダウンで変更を元に戻すようにします)。この戦術は、テストごとにフィクスチャを再構築するよりもエラーが発生しやすいですが、毎回フィクスチャを構築するのに時間がかかりすぎる場合、またその場合にのみ価値があるかもしれません。

データベースが分離の欠如問題におけるよくある原因ですが、メモリ内でも問題が発生することはたくさんあります。特に、静的なデータやシングルトンには注意してください。この種の問題の良い例は、現在ログインしているユーザのようなコンテキスト環境です。

テストで明示的なティアダウンがある場合合、ティアダウン中に例外が発生しないように注意してください。このような例外が発生した場合、テストは合格しますが、その後のテストで分離の欠如による失敗を引き起こす可能性があります。そのため、ティアダウンで問題が発生した場合には、すぐに気づけるようにしましょう。

分離をあまり重視せず、明確な依存関係を定義してテストを指定した順番で実行させることを好む人もいます。しかし、私は、テストのサブセットを実行したりテストを並列化したりする際の柔軟性を高めることができるので、分離を重視した方が良いと考えています。

## 非同期的な挙動



[^1]: TDDの支持者の多くがテストの主なメリットは要件と設計を推進する点にあると考えることは知っています。これが大きな利点であることには同意しますが、私はリグレッションスイートが自動化されたテストが私たちに与える最大の利点であると考えています。TDDがなくても、テストはそのためのコストを払う価値があります。
[^2]: テストの失敗は、もちろんコードが行うべきことが変更されたことに起因しますが、テストが新しい動作を反映していないことに起因することも時折あります。これは本質的にはテストのバグですが、すぐに捕まえられれば同じように簡単に修正できます。
[^3]: 非決定的テストにも有用な役割があります。ランダムな値を使用するテストは、エッジケースを探し出すのに役立ちます。パフォーマンステストは常に異なる値を返してきます。しかし、この種のテストは自動化されたリグレッションテストとは全く異なります。
[^4]: Mingle チームは、非決定的なテストを迅速に見つけて修正するスキルがあり、それを迅速に実行するために十分な規律を持っているので、これはうまく機能します。もし隔離テストが失敗したためにあなたのビルドが長く壊れたままになるのであれば、継続的インテグレーションの価値を失うことになります。ですから、ほとんどのチームには、隔離テストはメインパイプラインから外しておくことをお勧めします。
[^5]: 堅苦しい定義はありませんが、私は初期のエクストリームプログラミングの用語である「ユニットテスト」をより細かいものを意味するものとして、「機能テスト」をよりエンドツーエンドで機能に関連したテストを指すものとして使っています。
[^6]: 1つのコツは、テスト実行のたびにデータベースを開く前に、初期データベースを作成しファイルシステムコマンドを使ってコピーすることです。ファイルシステムのコピーは、データベースコマンドを使ってデータをロードするよりも高速であることが多いです。
[^7]: もちろん、このやり方はトランザクションをコミットせずにテストを実行できる場合にのみ機能します。
